#!/usr/bin/env python3
#

import base64
import json
import re
from argparse import ArgumentParser
from html import unescape
from html.parser import HTMLParser
from urllib.request import urlopen

from bs4 import BeautifulSoup
from unidecode import unidecode

import puz


class ParseAmuseLabsHtml(HTMLParser):
    def __init__(self):
        super().__init__()
        self.current_tag = None
        self.puzzle_dict = None

    def handle_starttag(self, tag, attrs):
        self.current_tag = tag

    def handle_data(self, data):
        if self.current_tag == "script":
            #  Look for the raw data
            r = re.compile(r"\s*window\.rawc\s*=\s*'(.*?)';")
            for line in data.split("\n"):
                m = r.match(line)
                if m:
                    b64 = m.groups()[0]
                    try:
                        b64 = b64.decode()
                    except (UnicodeDecodeError, AttributeError):
                        pass
                    try:
                        self.puzzle_dict = json.loads(base64.b64decode(b64))
                    except TypeError:
                        self.puzzle_dict = json.loads(base64.b64decode(b64).decode())


def do_latinize(s):
    GREEK_ALPHABET_MAP = {
        u"\u0391": "Alpha",
        u"\u0392": "Beta",
        u"\u0393": "Gamma",
        u"\u0394": "Delta",
        u"\u0395": "Epsilon",
        u"\u0396": "Zeta",
        u"\u0397": "Eta",
        u"\u0398": "Theta",
        u"\u0399": "Iota",
        u"\u039A": "Kappa",
        u"\u039B": "Lamda",
        u"\u039C": "Mu",
        u"\u039D": "Nu",
        u"\u039E": "Xi",
        u"\u039F": "Omicron",
        u"\u03A0": "Pi",
        u"\u03A1": "Rho",
        u"\u03A3": "Sigma",
        u"\u03A4": "Tau",
        u"\u03A5": "Upsilon",
        u"\u03A6": "Phi",
        u"\u03A7": "Chi",
        u"\u03A8": "Psi",
        u"\u03A9": "Omega",
        u"\u03B1": "alpha",
        u"\u03B2": "beta",
        u"\u03B3": "gamma",
        u"\u03B4": "delta",
        u"\u03B5": "epsilon",
        u"\u03B6": "zeta",
        u"\u03B7": "eta",
        u"\u03B8": "theta",
        u"\u03B9": "iota",
        u"\u03BA": "kappa",
        u"\u03BB": "lamda",
        u"\u03BC": "mu",
        u"\u03BD": "nu",
        u"\u03BE": "xi",
        u"\u03BF": "omicron",
        u"\u03C0": "pi",
        u"\u03C1": "rho",
        u"\u03C3": "sigma",
        u"\u03C4": "tau",
        u"\u03C5": "upsilon",
        u"\u03C6": "phi",
        u"\u03C7": "chi",
        u"\u03C8": "psi",
        u"\u03C9": "omega",
    }

    #  Reserved for any characters where we want to diverge from unidecode.
    replacements = {}
    replacements.update(
        {u: "*{}*".format(latin_equiv) for u, latin_equiv in GREEK_ALPHABET_MAP.items()}
    )
    for u, r in replacements.items():
        s = s.replace(u, r)
    return unidecode(s)


def do_despan(s):
    """Remove any span tags from a string."""
    #  Some outlets occasionally wrap clues in span tags.  Unconditionally clean
    #  those up.
    soup = BeautifulSoup(s, features="html.parser")
    for s in soup.findAll("span"):
        s.unwrap()
    return str(soup)


#  Example URL:
#  https://cdn3.amuselabs.com/atlantic/crossword?id=atlantic_20200510&set=atlantic
args_parser = ArgumentParser()
args_parser.add_argument("amuselabs_url", help="A URL with a an Amuse Labs crossword")
args_parser.add_argument("output_puz", help="An output file for the generated .puz")
args = args_parser.parse_args()

html = urlopen(args.amuselabs_url)
html_parser = ParseAmuseLabsHtml()
html_parser.feed(html.read().decode())

amuse_puz = html_parser.puzzle_dict

p = puz.Puzzle()
p.title = do_latinize(unescape(amuse_puz["title"]))
p.author = do_latinize(unescape(amuse_puz["author"]))
p.width = amuse_puz["w"]
p.height = amuse_puz["h"]
p.fill = "-" * p.width * p.height

rebus_table = []
rebus_solutions = []

#  There may be subtleties with non-standard numbering that aren't yet handled,
#  or can't be handled.
p.solution = ""
for row_n in range(p.height):
    for ic, column in enumerate(amuse_puz["box"]):
        c = column[row_n]
        if len(c) > 1:
            # It's a rebus square

            # If rebus table not initialized, do it.
            if not rebus_table:
                rebus_table = [0] * p.width * p.height

            # If we have not seen this rebus, add an entry to solutions
            if c not in rebus_solutions:
                rebus_solutions.append(c)

            # Add the solution key + 2 to the table.
            rebus_table[row_n * p.width + ic] = rebus_solutions.index(c) + 2

            # Add the first letter to the solution
            p.solution += c[0]
        else:
            p.solution += puz.BLACKSQUARE if c == "\x00" else c

#  If there were any rebus squares, set the rebus table and solutions
if rebus_table:
    r = p.rebus()
    r.solutions = dict(enumerate(rebus_solutions, start=1))
    r.table = rebus_table

    #  OK to set this empty now, but the extension needs to be in the list to be
    #  saved.
    p.extensions[puz.Extensions.Rebus] = b""

p.clues = [
    do_latinize(unescape(do_despan(c["clue"]["clue"])))
    for c in sorted(
        amuse_puz["placedWords"], key=lambda x: (x["clueNum"], not x["acrossNotDown"])
    )
]

m = puz.Markup(p)
m.markup = [puz.GridMarkup.Default] * (p.width * p.height)

sawShaded = False
for ci in amuse_puz.get("cellInfos", []):
    if ci.get("isCircled", False):
        m.markup[ci["x"] + p.width * ci["y"]] = puz.GridMarkup.Circled
    if ci.get("bgColor", None):
        sawShaded = True
        m.markup[ci["x"] + p.width * ci["y"]] = puz.GridMarkup.Circled

if sawShaded:
    p.notes = "Some shaded cells in the original have been marked with circles."

p.helpers["markup"] = m

p.save(args.output_puz)
